\chapter{Random Number Generators (RNGs)}

    En este capitulo se presentan los conceptos necesarios para comprender cómo funcionan las diferentes clases de generadores de números aleatorios, sus fuentes de aleatoriedad, sus principales características y cuales son factibles para su uso en FPGA.

   
    \section{Parámetros de evaluación de los TRNG}
        
        \subsection{Parámetros relacionados con la calidad}	

            \subsubsection{Fuentes de aleatoriedad en dispositivos lógicos} 

            Los TRNG pueden utilizar fuentes de ruido físicas o no físicas. Sin embardo, en el caso de los dispositivos lógicos, las fuentes de ruido físico son bastante limitadas, ya que estos dispositivos se diseñan para ser deterministas y estar en un estado bien definido en todo momento. Por lo tanto, para generar números verdaderamente aleatorios, es necesario contar con un fenómeno aleatorio incontrolable que pueda utilizarse como fuente de aleatoriedad. Los fenómenos físicos más utilizados para generar números aleatorios en los dispositivos lógicos son:
	
            \begin{itemize}[noitemsep]
                \item Señales analógicas: como el ruido de disparo de un diodo, el ruido térmico, etc.		

                \item Metaestabilidad: es la capacidad de un circuito de persistir en un estado indefinido durante un periodo de tiempo indefinido.
                
                \item Jitter del reloj: es una variación del flanco del reloj desde su posición ideal.
                
                \item Caos: es un comportamiento imprevisible de un sistema determinista, muy sensible a sus condiciones iniciales, lo que significa que incluso el más mínimo cambio en el estado inicial produce resultados muy diferentes.
            \end{itemize}		
	
            La presencia de comportamientos impredecibles en un dispositivo lógico puede tener consecuencias graves en el comportamiento del sistema global. A pesar de que estos eventos son inevitables debido a la naturaleza física de la tecnología, los vendedores de dispositivos lógicos sueles minimizarlos. Por ello, es fundamental examinar de forma crítica los métodos de extracción de aleatoriedad utilizados en el diseño de los TRNG para mantenernos al día con la evolución de la tecnología.

            La mayoría de los dispositivos lógicos, y concretamente los FPGA, no contienen bloques analógicos y de tenerlos seria necesario un convertidor analógico digital (ADC) para poder utilizar una señal analógica, lo cual agrega otra capa de complejidad. Por esta razón las fuentes de aleatoriedad más utilizadas en dispositivos lógicos están relacionadas con el funcionamiento de las puertas lógicas. Se pueden utilizar varios fenómenos y sus combinaciones como la variación del retardo de las puertas lógicas, el comportamiento analógico de las puertas lógicas entre dos niveles lógicos (metaestabilidad), la violación del tiempo de preparación y retención y el ruido térmico generado dentro del dispositivo.	
					
	        La inestabilidad de los retardos de las puertas lógicas provoca variaciones en la propagación de la señal a lo largo del tiempo. Estas variaciones pueden verse como una inestabilidad  en el período del reloj (jitter) en los generadores de reloj que contienen elementos de retardo ensamblados en un circuito cerrado (osciladores en anillo). Asimismo, la variación del tiempo de propagación se utiliza también en generadores con elementos de retardo ensamblados en una cadena abierta. La cadena se utiliza para aumentar o ajustar el retardo total.

            La tecnología digital permite implementar fácilmente resistencias y condensadores, cuyo ruido térmico generado en las resistencias puede utilizarse para modular la frecuencia de un oscilador de funcionamiento libre, también conocido como oscilador RC. De esta manera, el ruido térmico se convierte al dominio temporal, lo que facilita su extracción. No obstante, este principio no es aplicable en FPGAs, ya que carecen de estructuras adecuadas para ello.

            Algunos generadores utilizan el jitter de seguimiento introducido por los bucles de fase bloqueada, phase locked loops (PLL), para generar números aleatorios. Estos generadores, llamados PLL analógicos, pueden implementarse fácilmente en dispositivos digitales, incluidos los FPGA, debido a que el filtro RC presente en dichos PLL es el único bloque ``analógico'' y puede implementarse utilizando la misma tecnología. Por lo tanto, es posible considerar un TRNG basado en PLL como un generador que se puede implementar en dispositivos lógicos en general
					
            \subsubsection{Métodos de extracción de aleatoriedad}	

            En los dispositivos lógicos que carecen de bloques analógicos, a menudo se extrae la aleatoriedad mediante el muestreo de una señal (reloj) en los flancos ascendentes o descendentes de una señal (reloj) de referencia utilizando flip-flops síncronos o asíncronos (latches). El flujo de bits aleatorio se puede obtener de dos maneras: muestreando señales aleatorias a intervalos regulares o muestreando señales regulares a intervalos de tiempo aleatorios. En los sistemas síncronos, se prefiere el primer método para garantizar una tasa constante de bits a la salida.

            La elección entre flip-flops síncronos y asíncronos resulta crítica en las FPGA. Esto se debe a que los flip-flops síncronos se encuentran cableados en celdas lógicas optimizadas, reduciendo así su comportamiento metaestable. En cambio, los latches suelen implementarse en tablas de consulta (LUT) y, por tanto, están más expuestos a sufrir comportamiento metaestable. Sin embargo, aún no se ha evaluado adecuadamente la influencia del uso de flip-flops síncronos y asíncronos en la extracción de aleatoriedad en las FPGA.
                
            El método de extracción de la aleatoriedad está estrechamente vinculado al principio básico del generador y a la fuente de aleatoriedad utilizada. En algunos casos, el proceso de extracción de la aleatoriedad y el postprocesamiento se fusionan en el mismo bloque y no pueden ser separados. En tales casos, la entropía de la fuente de aleatoriedad se modifica por el postprocesamiento, lo que dificulta su medición y evaluación precisa.
                
            En la evaluación de un generador de números aleatorios, la fuente de aleatoriedad y el método de extracción están estrechamente relacionados y no pueden evaluarse por separado. Por tanto, lo más adecuado es evaluar ambos parámetros conjuntamente, tomando en cuenta la entropía contenida en el ruido digital.
    
            \subsubsection{Técnicas de postprocesamiento}
                
            La evaluación de los TRNG se basa principalmente en pruebas estadísticas que se aplican a las secuencias aleatorias producidas por el generador. Sin embargo, en ocasiones la fuente de entropía puede presentar ciertas debilidades que se traducen en la generación de números no aleatorios, como largas secuencias de ceros o unos. Por esta razón, puede ser necesario aplicar postprocesamiento para mejorar las propiedades estadísticas de los números aleatorios, como aumentar la entropía por bit, reducir el sesgo y la correlación, entre otros.
                
            La calidad de la señal de ruido digital obtenida en el bloque de extracción de aleatoriedad puede verse afectada por diversas razones:

            \begin{enumerate}[noitemsep, label=(\alph*)]
                \item La entropía de la fuente no es lo suficientemente alta, lo cual suele ocurrir cuando se utiliza la metaestabilidad como fuente de aleatoriedad.
                \item La entropía, que es alta en la señal original, no se extrae adecuadamente.
                \item Las muestras extraídas están correlacionadas entre sí. 
            \end{enumerate}		

            % \textcolor{red}{La entropía por bit en la salida del generador se incrementa principalmente a expensas de la disminución de la tasa de bits de salida, sin embargo nunca puede generar entropía.}
	
	        El objetivo del bloque de postprocesamiento es mejorar la calidad de la secuencia de salida, de manera que no se distinga de una secuencia aleatoria ideal que esté libre de correlaciones y se distribuya uniformemente. En general, existen dos tipos principales de postprocesamiento:

            \begin{enumerate}
                \item Postprocesamiento algorítmico

                    Consiste en la aplicación de un algoritmo de procesamiento de datos con el objetivo de mejorar los parámetros estadísticos de los números generados. Entra las técnicas más utilizadas se encuentra la operación XOR de varios bits de salida, la corrección de Von Neumann y varios tipos de algoritmos de compresión, entre otros.
                \item Posprocesamiento criptográfico 

                    Emplea algoritmos criptográficamente seguros para asegurar la imprevisibilidad de los números generados en dirección de avance y/o retroceso en caso de fallo en la fuente física de aleatoriedad. La implementación de un postprocesamiento criptográfico refuerza la robustez del TRNG frente a posibles ataques.
            \end{enumerate}
    
            Las técnicas más utilizadas para el postprocesamiento de la señal obtenida en el bloque de extracción de aleatoriedad son: 
	
            \begin{itemize}
                \item Corrector XOR 
                
                    Es una función lineal simple que aplica una operación XOR en bloques no superpuestos de $n$ bits para generar un bit de salida. Puede reducir drásticamente el sesgo de la salida del generador a costa de reducir su tasa de bits $n$ veces. Sin embargo, el sesgo del flujo de bits de salida sólo se reduce si los bits originales son independientes. Las principales ventajas del corrector XOR son su simplicidad y la posibilidad de mantener una tasa de bits de salida constante.

                \item Corrector de Von Neumann
                
                    Es una función no lineal sencilla que toma pares sucesivos de bits y, si los bits no son iguales, utiliza el primer bit del par y descarta los pares idénticos. Por tanto, la tasa de bits de salida depende de los datos.

                    Aunque la secuencia de entrada sea estacionaria y pueda estar sesgada, la salida no tendrá sesgo. Sin embargo, si la secuencia original está autocorrelacionada, la salida también puede estar autocorrelacionada. También es importante resaltar que el corrector de Von Neumann producirá una salida sesgada si la secuencia de entrada presenta un ciclo con periodo 2. Si se implementa el corrector en hardware, puede interferir con el generador y resultar en este tipo de ocurrencia.

                \item Linear Feedback Shift Registers (LFSRs)
                
                    Los LFSR son ampliamente utilizados en generadores de secuencias de bits aleatorias por varias razones. En primer lugar, son fáciles de implementar en hardware. En segundo lugar, pueden generar secuencias con periodos largos. En tercer lugar, pueden producir secuencias con buenas propiedades estadísticas. Y en cuarto lugar, debido a su estructura, son fáciles de analizar utilizando técnicas algebraicas.

                    Un LFSR de longitud $L$ consta de $L$ elementos de retardo que pueden almacenar un bit cada uno y tiene una entrada, una salida y un reloj que controla el movimiento de los datos. En cada unidad de tiempo, se llevan a cabo las siguientes operaciones:

                \begin{enumerate}[noitemsep, label=(\roman*)]
                     \item El contenido del primer elemento de retardo sale y forma parte de la secuencia de salida.
                     \item El contenido del elemento $i$ se mueve a la etapa $i - 1$ para cada $i$, $1 \leq i \leq L - 1$.
                     \item El nuevo contenido del último elemento de retardo es el bit de retroalimentación que se calcula sumando módulo 2 los contenidos anteriores de un subconjunto fijo de elementos, dependiendo del polinomio subyacente.
                 \end{enumerate}	
                
                \item Funciones resilientes
                
                    Son funciones booleanas especiales que se utilizan en criptografía y teoría de la codificación. Su estudio es fundamental en el diseño de algoritmos de clave simétrica. Para analizar estas funciones, es importante considerar su grado, su forma algebraica normal, la transformada Möbius, la transformada de Walsh-Hadamard entre otros conceptos relacionados.

                    En palabras simples, las funciones resilientes resultan apropiadas para el postprocesamiento debido a que el conocimiento de el conocimiento de cualquier conjunto de $m$ valores de entrada no permite adivinar la salida con una precisión mayor a la del azar. Estas funciones se fundamentan en el mismo principio que los códigos de corrección de errores. Mientras que dichos códigos se emplean para eliminar errores aleatorios, las funciones resilientes se usan para extraer los bits aleatorios presentes.

                    La señal binaria sin procesar (RBS), también conocida como ruido digital, puede ser interpretada como un flujo de bits que contiene redundancia, y la función resiliente disminuye la tasa de bits al mismo tiempo que extrae los bits aleatorios. De esta manera, la función resiliente incrementa la entropía por bit en la salida del generador. 

                \item Cifrado de la señal de ruido digital
                
                    Este tipo de postprocesamiento del ruido digital emplea las propiedades de difusión y confusión inherentes a las funciones criptográficas. Las características estadísticas óptimas de la mayoría de los algoritmos de cifrado pueden ser aprovechadas para enmascarar las imperfecciones del generador. Una ventaja de este enfoque radica en que la clave de cifrado puede ser utilizada como variable criptográfica para alterar dinámicamente el comportamiento del generador. A pesar de que este tipo de bloque de postprocesamiento (el cifrador) resulta bastante complejo y costoso, el TRNG puede reutilizar (compartir) el cifrador que se emplea para cifrar los datos.
                
                
                \item Hashing de la señal de ruido digital

                    Uno de los métodos más seguros, aunque también de los más tiempo consume, es el postprocesamiento criptográfico basado en funciones hash, como MD5, SHA-1, entre otras. Este enfoque aprovecha las propiedades de difusión y unidireccionalidad (a diferencia del cifrado de la señal binaria sin procesar) de las funciones hash para garantizar la imprevisibilidad de los bits generados por el TRNG en caso de un fallo completo en la fuente de ruido. En esta situación, debido a la propiedad de no linealidad de las funciones hash, el TRNG se comportará como un PRNG.
                
            \end{itemize}
	
            El postprocesamiento puede incrementar la tasa de entropía a la salida del generador, aunque ello implique reducir la tasa de bits de salida, no obstante, nunca puede generar entropía por si mismo. Idealmente, se busca producir números aleatorios sin procesar de alta calidad, de manera que el postprocesamiento no sea necesario. Este enfoque es especialmente beneficioso en aplicaciones de alta seguridad.

            \subsubsection{Tasa de bits de salida}

            En muchas aplicaciones criptográficas, la velocidad de generación de números aleatorios es un parámetro critico a considerar, después de la seguridad. Por lo general, velocidades de salida de entre 100 kilobits por segundo hasta 1 megabit por segundo son suficientes. Sin embargo, hay ciertas aplicaciones que requieres una generación de números aleatorios a alta velocidad, como los servidores de telecomunicaciones de alta velocidad. Estos servidores necesitan generar claves de sesión a velocidades que pueden alcanzas decena de megabits por segundo. Por ejemplo, un servidor de 10 GBit necesitaría unos 20 Mbits/s de datos aleatorios para generar una clave de sesión de 128 bits por cada bloque de datos de 64 kB, con el fin de resistir los ataques de canal lateral.

            Otro aspecto crucial a tener en cuenta en los generadores de números aleatorios es la variabilidad de su tasa de bits de salida. Algunos generadores producen números aleatorios periódicamente, mientras que otros generan la salida en intervalos de tiempo irregulares, lo que requiere una memoria intermedia FIFO para almacenar los números generados. Una solución alternativa consiste en estimar la tasa de bits más baja disponible en la salida y muestrear la salida a esa tasa. No obstante, la desventaja de la primera solución es que las memorias intermedias FIFO pueden ser bastante grandes, dependiendo de la velocidad de bits promedio de salida y la demanda de números aleatorios. Por otro lado, la desventaja de la segunda solución radica en que si la tasa de bits estimada resulta ser incorrecta, puede haber momentos en los que los números aleatorios no estén accesibles en la salida.
	
        \subsection{Parámetros relacionados con la seguridad}

            \subsubsection{Modelado matemático de TRNG}
            
            En un proceso de certificación de seguridad, la evaluación del diseño y la implementación del generador es fundamental. El objetivo principal es cuantificar la entropía por bit aleatorio, la cual es una propiedad de las variables aleatorios y no de las observaciones realizadas (números aleatorios). Para realizar una cuantificación precisa de la entropía, es necesario analizar la distribución de las variables aleatorias a través de un modelo estocástico. Dicho modelo especifica una familia de distribuciones de probabilidad de variables aleatorias, permitiendo verificar un límite inferior de entropía para la señal binaria en bruto. En diversos estudios, se han utilizado modelos que proporcionan límites inferiores para la entropía condicional media por número aleatorio interno. Estos modelos permiten comprobar la entropía de los números generados en tiempo real y son utilizados por varios autores en la evaluación de la calidad de los generadores de números aleatorios.

            \subsubsection{Comprobabilidad}

            La comprobabilidad o verificación interna se refiere a la capacidad del generador de evaluar la entropía de la señal binaria sin procesar la cual debe estar disponible para su evaluación. Esta funcionalidad es necesaria en los procedimientos de evaluación más recientes de TRNG. Sin embargo, en los casos en que la extracción de aleatoriedad y el postprocesamiento se fusionan en un solo proceso, la señal aleatoria sin procesar no siempre está disponible. Incluso cuando esta señal está disponible, a veces se compone de un patrón pseudoaleatorio combinado con un flujo de bits verdaderamente aleatorio, lo que dificulta la evaluación estadística de la señal. 

            \subsubsection{Evaluación de seguridad}

            En ocasiones resulta muy complicado, e incluso imposible, construir un modelo estocástico para un generador específico. En tales situaciones, se puede utilizar un enfoque alternativo para validar el uso del generador en aplicaciones criptográficas. Este enfoque se basa en el análisis del impacto de un entorno cambiante o de un ataque al generador, lo que se conoce como evaluación de seguridad. Hay tres posibilidades: 
            
            \begin{enumerate}[noitemsep, label=(\roman*)]
                \item Se puede probar que el generador no puede fallar como resultado de un ataque o un entorno cambiante.
                \item No existen pruebas de seguridad ni ataques.
                \item Se ha informado de algún ataque a un generador en particular.
            \end{enumerate}		

        \subsection{Parámetros relacionados con el diseño}	
    
            \subsubsection{Uso de recursos}
            
            Para evaluar la viabilidad de diferentes principios de TRNG, es crucial examinar los recursos necesarios para la implementación del generador en hardware. En general, todos los tipos de recursos disponibles en las FPGA pueden utilizarse para generar números aleatorios, incluyendo células lógicas basadas en LUT o multiplexores, bloques de memoria integrados, bloques de reloj con PLLs y DLLs, osciladores RC integrados, multiplicadores cableados, interconexiones programables entre otros.
                
            Los FPGA tienen una gran cantidad de celdas lógicas, lo que hace que su uso no suponga normalmente un problema en cuanto al área lógica. Sin embargo, la topología y los parámetros eléctricos de las interconexiones programables están fuertemente condicionados por la tecnología utilizada. En el caso de los diseños de TRNG, a menudo se requiere la intervención manual del diseñador durante la colocación y el enrutamiento (Placement and Routing). En cuanto a este último, algunos diseños pueden implementarse sin dificultad en una familia de FPGA, pero resultan complicados o incluso imposibles de implementar en otras. Asimismo, la elección y el número de bloques cableados integrados suelen ser mucho más limitados (PLL, osciladores RC, multiplicadores, bloques de memoria), y varían según el proveedor y la tecnología. La utilización de estos bloques puede ser un factor limitante para la reutilización del principio TRNG en diferentes plataformas FPGA.

            \subsubsection{Consumo de energía}
                
            El consumo de energía del generador está estrechamente relacionado con su fuente de aleatoriedad, la frecuencia de reloj utilizada y la complejidad del algoritmo. En algunas aplicaciones donde la eficiencia energética es crítica, el generador puede detenerse cuando no se está utilizando. No obstante, es importante tener en cuenta que la capacidad de controlar la generación del flujo de bits puede ser utilizada como una vía de ataque al generador.
                
            \subsubsection{Viabilidad en FPGAs}

            La implementación de TRNGs en FPGAs es mucho más limitada en comparación con su implementación en ASICs. La mayoría de los TRNG implementados en ASIC utilizan componentes analógicos para generar aleatoriedad, como TRNG basados en caos que utilizan convertidores analógico-digitales, generadores basados en osciladores de funcionamiento libre que utilizan ruido térmico de diodos y resistencias, y para procesar la aleatoriedad se utilizan amplificadores operacionales y comparadores. Sin embargo, la mayoría de estos bloques funcionales no están disponibles en FPGAs, aunque algunos de ellos pueden estar disponibles en familias seleccionadas, por ejemplo, osciladores RC en FPGAs de Actel Fusion y PLLs analógicos en la mayoría de las familias de Altera y Actel, estos no se encuentran en las antiguas familias de Xilinx. Algunos generadores son difíciles de implementar o no son viables en FPGAs, mientras que otros son viables solo en FPGAs seleccionadas. Sin embargo, los principios más generales son viables en todas las FPGAs.
            
            \subsubsection{Automatización del diseño}
            
            La disponibilidad de recursos en las FPGA no garantiza la implementación exitosa de un generador, ya que (el rango de tolerancias de) ciertos parámetros tecnológicos pueden limitar su viabilidad. El enrutamiento y sus características son los principales factores que restringen la implementación de los generadores en FPGAs. Algunos generadores requieren un enrutamiento equilibrado, lo que implica una colocación precisa de los módulos y un enrutamiento óptimo, por ejemplo la colocación simétrica de dos módulos en relación con otro módulo. Mientras que la mayoría de las herramientas de diseño FPGA permiten un control preciso de la colocación, el proceso de enrutamiento puede ser difícil o imposible de controlar en algunas familias, como Actel. 

            Incluso cuando el enrutamiento puede ser controlado como en las familias Altera y Xilinx, los retardos en la red de enrutamiento configurable varían entre dispositivos, lo que dificulta la equilibración de las interconexiones de los módulos de forma general. Por lo tanto, el diseño dependerá del dispositivo y requerirá equilibrio manual para cada uno. Esta intervención manual no es aceptable desde el punto de vista de una implementación práctica del generador. Aunque los mejores generadores (muy raros) pueden mapearse automáticamente en todas las familias de FPGA, la intervención manual es aceptable para la implementación del generador en cada familia y tipo de dispositivo. Sin embargo, los generadores que requieren una optimización manual por dispositivo no son viables para aplicaciones industriales.


\section{Fuentes de aleatoriedad en los dispositivos lógicos}

        \subsection{Jitter del reloj}

            Como se mencionó anteriormente, el jitter del reloj es una fuente confiable de aleatoriedad en dispositivos lógicos. El término ``jitter'' se refiere a la incertidumbre en la oscilación del reloj en el dominio del tiempo. En otras palabras, se trata de la variación a corto plazo de un evento con respecto a su posición ideal. Por lo general, se mide como la variación en el tiempo del cruce por cero (flanco ascendente o descendente) de la señal de reloj. Aunque esta definición proporciona una comprensión básica del concepto, cuantificar el jitter puede ser confuso debido a la variedad de técnicas de medición utilizadas en diferentes aplicaciones y a la falta de consenso entre los autores en la definición precisa del término \cite{Valtchanov2008}.

            Se supone que una señal de reloj ideal en dispositivos lógicos digitales es una señal rectangular con un ciclo de trabajo del 50\% y un periodo estable. Pero debido a diversos ruidos que afectan a los dispositivos electrónicos, la señal de reloj nunca es absolutamente estable y sus bordes se mueven de su posición estable. En otras palabras, la fase de la señal de reloj fluctúa. Esta fluctuación puede verse como un jitter del reloj en el dominio del tiempo y como un ruido de fase en el dominio de la frecuencia. En los dispositivos lógicos, la fluctuación de reloj suele ser no deseada, pero inevitable. Dado que el jitter afecta negativamente a las comunicaciones de alta frecuencia y a los sistemas de alta velocidad, se ha estudiado y caracterizado en profundidad.

            En los sistemas analógicos, el jitter se caracteriza mejor en el dominio de la frecuencia. De este modo, los componentes de fase y amplitud pueden estudiarse y caracterizarse por separado. En cambio, en los sistemas digitales, las propiedades temporales del jitter son más importantes y, por tanto, el jitter se caracteriza en el dominio temporal \cite{Fischer2003}.

            El jitter del reloj en un sistema digital es una desviación del flanco de reloj real con respecto a un flanco de reloj ideal. Una señal de reloj ideal se define mediante la ecuación (\ref{eq:señal_periodica}), donde $t(n)$ representa el tiempo del periodo $n$-ésimo de una señal de reloj y $T$ es el periodo de una señal de reloj.

            \begin{equation}
                t(n) = n \cdot T 
                \label{eq:señal_periodica}
            \end{equation}

            En la práctica, una señal de reloj real no alcanza siempre múltiplos enteros de su período ideal, sino que sus flancos fluctúan alrededor de este valor debido al jitter. Esta variación es causada por diversos fenómenos físicos, como el ruido térmico, el ruido de la fuente de alimentación y el ruido electromagnético ambiental, entre otros. La Figura \ref{fig:F9_jitter} muestra cómo se ve una señal de reloj afectada por el jitter.

            \begin{figure}[hbtp]
                \caption{Jitter del reloj.}
                \centering
                \includegraphics[width=0.8\textwidth]{F9_jitter}
                \label{fig:F9_jitter}
            \end{figure}
                
            La Figura \ref{fig:F10_fluctuaciones} muestra la causa principal del jitter en los circuitos digitales. Los circuitos digitales utilizan un nivel de referencia, generalmente ubicado en el centro del rango de voltaje de funcionamiento, para detectar los flancos de reloj. Es importante que este nivel de referencia sea lo más estable posible, pero en la práctica sufre fluctuaciones debido a diversos tipos de ruido. Cuando el nivel de referencia se desplaza, los flancos del reloj se detectan antes o después de lo previsto, lo que resulta en una variación temporal conocida como jitter de reloj.

            \begin{figure}[hbtp]
                \caption{Fluctuaciones del nivel de referencia originadas por ruidos analógicos que provocan jitter del reloj en los circuitos digitales. \cite{Petura2019}}
                \centering
                \includegraphics[width=0.8\textwidth]{F10_fluctuaciones}
                \label{fig:F10_fluctuaciones}
            \end{figure}
        
            A continuación se explican las diferentes medidas de jitter que observamos en circuitos digitales y las relaciones entre ellas.

            \subsubsection{Jitter de fase}

                El jitter de fase es una diferencia entre el tiempo del $n$-ésimo flanco de reloj real $t_{r}(n)$ y el tiempo (fase) del $n$-ésimo flanco de reloj ideal. La ecuación (\ref{eq:jitter_fase}) define esta relación.

                \begin{equation}
                    \delta_{\varphi}(n) = t_{r}(n) - n \cdot T_{\text{ref}}
                    \label{eq:jitter_fase}
                \end{equation}
                
                La Figura \ref{fig:F11_jitter_fase} ilustra este jitter para $n = 3.$. Para mayor claridad, sólo se muestra el jitter de fase de los flancos ascendentes, pero hay que tener en cuenta que el jitter de fase afecta a todos los flancos del reloj.

                \begin{figure}[hbtp]
                    \caption{Ilustración de la jitter de fase del segundo flanco ascendente de la señal de reloj. \cite{Petura2019}}
                    \centering
                    \includegraphics[width=0.8\textwidth]{F11_jitter_fase}
                    \label{fig:F11_jitter_fase}
                \end{figure}

                En la Figura \ref{fig:F11_jitter_fase} se muestra que el jitter de fase $\delta_{\varphi}(2)$ no solo se ve afectada por la desviación de fase de $t_{r}(2)$, sino que también contiene contribuciones a la desviación de $t_{r}(1)$. Esto se conoce como acumulación de jitter de fase y provoca que el jitter de fase observado aumente cuanto mayor sea $n$.

            \subsubsection{Jitter de periodo}

                El jitter de periodo es la diferencia entre un periodo de reloj real y el de uno ideal. Se define como se muestra en la ecuación (\ref{eq:jitter_periodo}), una diferencia de primer orden del jitter de fase.

                \begin{eqnarray}
                    \delta_{T}(n) & = & [t_{r} (n) - t_{r} (n-1)] - T_{\text{ref}}\\
                                  & = & \delta_{\varphi}(n) - \delta_{\varphi}(n-1)
                    \label{eq:jitter_periodo}
                \end{eqnarray}

                La Figura \ref{fig:F12_jitter_periodo} muestra el jitter de periodo. Podemos ver que los periodos reales cambian con el tiempo, a diferencia de los periodos ideales, que permanecen constantes.

                \begin{figure}[hbtp]
                    \caption{Ilustración de jitter de periodo de una señal de reloj real comparada con el reloj ideal.}
                    \centering
                    \includegraphics[width=0.8\textwidth]{F12_jitter_periodo}
                    \label{fig:F12_jitter_periodo}
                \end{figure}

            \subsubsection{Jitter de ciclo a ciclo}

                El jitter ciclo a ciclo es una diferencia de dos periodos de reloj reales consecutivos, tal y como se define en la ecuación (\ref{eq:jitter_ciclo}).
                
                \begin{eqnarray}
                    \delta_{c}(n) & = & T_{r} (n) - T_{r} (n-1)\\
                                  & = & [t_{r}(n) - t_{r}(n-1)] - [t_{r}(n-1) - t_{r}(n-2)] \\
                                  & = & \delta_{T}(n) - \delta_{T}(n-1)
                    \label{eq:jitter_ciclo}
                \end{eqnarray}

                Todas estas medidas de jitter están relacionadas entre sí, el jitter de periodo es la diferencia de primer orden del jitter de fase y el jitter ciclo a ciclo es la diferencia de primer orden del jitter de periodo. Por lo tanto, en general basta con medir sólo uno y calcular cualquier otro que pueda ser necesario. En la Figura \ref{fig:F13_jitter_ciclo} se muestra el jitter ciclo a ciclo.

                \begin{figure}[hbtp]
                    \caption{Ilustración de jitter de ciclo a ciclo.}
                    \centering
                    \includegraphics[width=0.8\textwidth]{F13_jitter_ciclo}
                    \label{fig:F13_jitter_ciclo}
                \end{figure}

            \subsubsection{Composición del jitter}

                El jitter del reloj suele tener dos componentes, ver la Figura \ref{fig:F14_jitter_componentes}, jitter aleatorio, causada por un fenómeno no determinista como el ruido térmico y jitter determinista, causada por algunos procesos deterministas.

                \begin{figure}[hbtp]
                    \caption{Composición del jitter del reloj.}
                    \centering
                    \includegraphics[width=0.6\textwidth]{F14_jitter_componentes}
                    \label{fig:F14_jitter_componentes}
                \end{figure}

                El jitter aleatorio sigue una distribución de probabilidad gaussiana y se rige por el teorema del límite central. Debido a su comportamiento aleatorio, se utilizan herramientas estadísticas, como la media y la desviación estandar, para medirlo. El jitter aleatorio surge de la suma de múltiples factores independientes inherentes a cualquier circuito eléctrico, como las vibraciones térmicas de las estructuras cristalinas de los semiconductores, las vibraciones térmicas de los átomos conductores y otros factores secundarios.

                Los componentes deterministas del jitter no siguen ninguna ley probabilística debido a su naturaleza determinista, lo que los hace generalmente difíciles de caracterizar. El jitter determinista presenta otros dos componentes, el jitter periódico y el jitter dependiente de los datos. Estos componentes suelen ser causados por variaciones en la fuente de alimentación, diafonía (cross-talk), interferencias electromagnéticas (EMI), conmutaciones simultáneas de salidas y otras señales interferentes que ocurren de manera regular.

                Cuando se trata de medir y cuantificar el jitter, una de las principales confusiones que surgen es que algunas métricas del jitter solo se aplican al jitter aleatorio y no al determinista, aunque este último está presente la mayor parte del tiempo.

                En el contexto de los TRNG, los componentes deterministas del jitter no son deseables ya que no proporcionan ninguna fuente real de aleatoriedad. La aleatoriedad solo se puede extraer del jitter causado por ruidos aleatorios. Por lo tanto, es importante conocer las propiedades estadísticas del jitter antes de generar números aleatorios a partir de él.

                Tanto el jitter aleatorio como el determinista pueden tener fuentes locales o globales. Las fuentes de jitter local afectan sólo a un área limitada del sistema electrónico, mientras que las fuentes de jitter global afectan a todo el sistema. Las fuentes locales de jitter suelen estar presentes en las proximidades de componentes de alta frecuencia y potencia, como osciladores y amplificadores. Las fuentes de jitter global son ruidos ambientales, ruidos procedentes de fuentes de alimentación, etc. 

                Desde un punto de vista estadístico, podemos distinguir entre ruidos independientes y dependientes. Los ruidos independientes no son fácilmente manipulables y suelen ser fáciles de caracterizar. Por esta razón, la mayoría de los diseños de TRNG utilizan la suma de ruidos independientes, también conocida como ruido gaussiano, como fuente de aleatoriedad. El desafío al diseñar un TRNG con ruido gaussiano es la necesidad de estimar solo la contribución de los ruidos no correlacionados (gaussianos) a los números aleatorios generados, descartando así las contribuciones de los ruidos dependientes a la aleatoriedad resultante.

            \subsubsection{Extracción de la aleatoriedad del jitter del reloj}

                El jitter del reloj se considera una buena fuente de aleatoriedad en los dispositivos digitales debido a que siempre está presente y contiene elementos aleatorios intrínsecos. Para generar números aleatorios a partir del jitter, es necesario digitalizarlo de alguna manera para producir bits aleatorios. El método más utilizado para extraer la aleatoriedad del jitter del reloj se basa en el muestreo del flanco de reloj con jitter. En la Figura \ref{fig:F17_extraccion_jitter} se muestra este método de extracción de aleatoriedad.

                \begin{figure}[hbtp]
                    \caption{Extracción de aleatoriedad de la señal de reloj con jitter mediante su muestreo en el flanco ascendente de la señal de reloj de referencia.}
                    \centering
                    \includegraphics[width=0.8\textwidth]{F17_extraccion_jitter}
                    \label{fig:F17_extraccion_jitter}
                \end{figure}

                Para producir bits aleatorios, la señal de reloj debe llegar durante el flanco afectado por el jitter de la señal con jitter. Esto requiere de una gran precisión en la sincronización del reloj, ya que el jitter es muy pequeño, normalmente del orden de los picosegundos o $1/1000$ del periodo del reloj. Además, incluso la señal de reloj de muestreo está sujeta a jitter, lo que aumenta la dificultad de una sincronización precisa. Por último, los bits aleatorios generados mediante el método de muestreo son propensos a estar sesgados, dependiendo en gran medida del ciclo de trabajo (duty cycle) del reloj muestreado. Si el ciclo de trabajo es del 50\%, la probabilidad de que el bit de salida sea 1 es del 50\%. Sin embargo, cuando el ciclo de trabajo está desequilibrado, la probabilidad de obtener 1 no es igual a la probabilidad de obtener 0, sino que es proporcional al ciclo de trabajo. A pesar de los inconvenientes de este método, sigue siendo el más utilizado para extraer aleatoriedad del jitter del reloj \cite{Sunar2007,Baudet2010,Rozic2015,Cherkaoui2013, Zhang2018}.

                Una de las formas de convertir el jitter aleatorio en bits aleatorios es acumular el jitter hasta que su tamaño sea mayor que el periodo de la señal muestreada \cite{Baudet2010}. En ese caso, cada muestreo de dicha señal produciría un resultado completamente impredecible.

                Uno de los TRNG que utiliza la acumulación de jitter es el TRNG basado en oscilador de anillo elemental (ERO-TRNG), propuesto y modelado en \cite{Baudet2010}. Su estructura interna se representa en la Figura \ref{fig:G0_ERO_TRNG_simple}. Consta de dos osciladores en anillo, un divisor de frecuencia y un flip-flop D.

                \begin{figure}[hbtp]
                    \caption{Elementary ring oscillator (ERO-TRNG).}
                    \centering
                    \includegraphics[width=0.8\textwidth]{G0_ERO_TRNG_simple}
                    \label{fig:G0_ERO_TRNG_simple}
                \end{figure}

                Un divisor de frecuencia permite establecer un periodo más largo entre dos muestreos del Oscilador de anillo 1, lo que permite que se acumule su jitter de fase. Cuando el valor de $K$ es suficientemente grande, cada bit de salida es completamente impredecible debido a la acumulada del jitter.

                En lugar de esperar más tiempo para acumular suficiente jitter, es posible reducir el tiempo de acumulación de jitter mediante el uso de múltiples relojes desfasados.  Existen dos principios comunes para producir múltiples relojes desfasados: el primero consiste en utilizar múltiples osciladores independientes tal y como propone \cite{Sunar2007}, mientras que el segundo se basa en utilizar múltiples salidas de un oscilador multifásico como propone \cite{Cherkaoui2013}.

        \subsection{Metaestabilidad}
            
            La metaestabilidad es la capacidad de un sistema para persistir en un estado ilegal durante un periodo de tiempo indefinido. Un ejemplo de metaestabilidad es el lanzamiento de una moneda, como se muestra en la Figura \ref{fig:F15_metaestabilidad}. Cuando se lanza una moneda, se espera que caiga sobre una de sus dos caras, las cuales representan estados legales. Sin embargo, cuando una moneda cae sobre su borde, el resultado del lanzamiento se vuelve incierto e ilegal, lo que se conoce como su estado metaestable. En contraste, cuando una moneda cae sobre alguna de sus caras, se encuentra en un estado estable. Para que una moneda permanezca en un estado metaestable, debe estar en un estado de equilibrio perfecto. La más mínima fuerza que se aplique hará que caiga sobre cualquiera de las dos caras.
            
            \begin{figure}[hbtp]
                \caption{Metaestabilidad de un lanzamiento de moneda.}
                \centering
                \includegraphics[width=0.7\textwidth]{F15_metaestabilidad}
                \label{fig:F15_metaestabilidad}
            \end{figure}

            \subsubsection{Metaestabilidad en dispositivos lógicos}
                En los dispositivos lógicos, puede producirse metaestabilidad en los registros durante el funcionamiento normal del dispositivo, cuando se violan los tiempos de establecimiento y retención del registro. Los registros (flip-flops) requieren que una señal de entrada sea estable durante cierto tiempo antes del flanco de reloj (establecimiento) y también durante cierto tiempo después del flanco de reloj (retención). Sólo así se garantiza que el registro tenga un valor bien definido dentro de un retardo especificado a la salida. Si no se respetan los tiempos de establecimiento y retención, el registro puede caer en un estado metaestable, en el que permanece durante un periodo de tiempo indeterminado antes de volver a su valor anterior o al nuevo.

                El hecho de que el registro acabe en el nuevo estado o en el anterior se determina por factores aleatorios, lo que hace que el resultado de la transición sea también aleatorio. Sin embargo, generar números aleatorios de esta forma es un gran desafío debido a la dificultad de lograr una sincronización suficientemente precisa entre las dos señales para que lleguen al registro al mismo tiempo. Esto se debe principalmente a los esfuerzos realizados por los fabricantes de dispositivos para reducir los tiempos de preparación y retención, evitando así los estados metaestables de los registros. En estos casos, los fabricantes de dispositivos realizan estudios exhaustivos de la vida útil de los dispositivos para determinar una tasa de fallos en el tiempo, failure in time (FIT) del dispositivo. La tasa de fallos en el tiempo esta en el rango de una cada $10^{9}$ horas. El FIT puede utilizarse para calcular el tiempo medio entre fallos, mean time between failures (MTBF), de un dispositivo y un diseño específicos. El MTBF sirve como estimación del tiempo entre dos fallos del sistema debidos a la metaestabilidad. Se calcula en función de las especificaciones del dispositivo y el diseño y su orden de magnitud típico es de decenas de años.

                Teniendo en cuenta el MTBF típico, se tardaría mucho tiempo e incluso años en generar un bit aleatorio utilizando sólo la metaestabilidad de un circuito como fuente de aleatoriedad. Por se considera que la metaestabilidad en sí no puede utilizarse para generar grandes cantidades de datos aleatorios.

            \subsubsection{Metaestabilidad oscilatoria}

                  En los dispositivos electrónicos, también puede presentarse otro tipo de metaestabilidad conocida como metaestabilidad oscilatoria. A diferencia de la metaestabilidad en los registros, este comportamiento no conduce a un estado indefinido, sino que el sistema oscila entre estados bajos y altos durante un tiempo indeterminado. En un estudio realizado en \cite{Reyneri1990}, se demostró que es posible inducir metaestabilidad oscilatoria al introducir un retardo adicional en un circuito RS-latch. De esta forma, el circuito se inicializa en un estado ilegal para obtener su comportamiento metaestable.
                        
                En \cite{Varchola2010}, se introdujo el oscilador en anillo de efecto transitorio, transient effect ring oscillator (TERO), que utiliza la metaestabilidad oscilatoria para generar aleatoriedad. Consiste en un RS-latch modificado, que se establece periódicamente en un estado ilegal al establecerlo y reiniciarlo al mismo tiempo, violando de forma efectiva los tiempos de establecimiento y retención de dicho latch. La estructura interna de un TERO se muestra en la Figura \ref{fig:F16_internal_tero}.

                \begin{figure}[hbtp]
                    \caption{Estructura interna de un TERO}
                    \centering
                    \includegraphics[width=0.6\textwidth]{F16_internal_tero}
                    \label{fig:F16_internal_tero}
                \end{figure}

                Cuando se activa una señal Ctrl, el TERO pasa a un estado oscilatorio, en el que permanece durante un periodo de tiempo aleatorio. Después de la transición oscilatoria, se establece en uno de los niveles lógicos (alto o bajo). Este estado final también es aleatorio. Sin embargo el número de oscilaciones en la salida del TERO y su estado final no son constantes. A diferencia de la metaestabilidad analógica, aquí la salida oscila entre dos estados definidos.

        \subsection{Modelos estocásticos y pruebas específicas}

            El modelo estocástico de un TRNG especifica una familia de distribuciones de probabilidad que contiene todas las posibles distribuciones de los números aleatorios sin procesar. Sus principales objetivos son caracterizar la probabilidad de que un bit de salida sea igual a uno ($P(X = 1))$) y la probabilidad de un vector de bits de cierto valor a la salida ($P(X_1 = x_1, X_2 = x_2, \ldots, X_n = x_n)$), y a partir de ellas estimar la tasa de entropía a la salida del generador.

            El uso de modelos estocásticos resulta práctico únicamente cuando las probabilidades que definen se basan en parámetros medibles. Para ilustrar esto, examinaremos más de cerca los modelos estocásticos mediante un ejemplo de un TRNG elemental basado en osciladores de funcionamiento libre, tal y como se describe en \cite{Baudet2010}. Los autores de este trabajo proponen un modelo basado en la fase de la señal de reloj generada por un oscilador de funcionamiento libre y definen la probabilidad de que un bit de salida sea uno mediante la ecuación (\ref{eq:probabilidad}).

            \begin{equation}
                P(X=1) = \frac{1}{2} - \frac{2}{\pi} \sin (2 \pi (\mu t + \varphi(0) ) ) e^{-2\pi^{2} \sigma^{2} t} + O(e^{-4\pi^{2} \sigma^{2} t})
                \label{eq:probabilidad}
            \end{equation}

            A partir de esta probabilidad, el límite inferior de entropía por bit a la salida del generador puede denotarse mediante la ecuación (\ref{eq:entropia_min}).

            \begin{equation}
                H_{\text{min}} \approx 1 - \frac{4}{\pi^{2} \ln (2)} e^{-4 \pi ^{2} Q} = 1 - \frac{4}{\pi^{2} \ln (2)} e^{ \frac{-4\pi^{2} \sigma_{\text{jit}}^{2} T_{2} }{T_{1}^{3}} }
                \label{eq:entropia_min}
            \end{equation}
            
            Podemos ver que la entropía depende de tres parámetros medibles: los periodos del oscilador ($T_{1}$, $T_{2}$) y el jitter combinado ($\sigma_{\text{jit}}$). Así que midiendo estos parámetros podemos estimar la entropía a la salida de los generadores. Esto es importante por dos razones: el TRNG puede caracterizarse en la fase de diseño y la tasa de entropía en su salida puede controlarse durante el funcionamiento normal del generador. Los periodos de los dos osciladores son fáciles de medir incluso dentro del dispositivo. La principal dificultad en la estimación de la entropía en línea está relacionada con la medición de $\sigma_{\text{jit}}^{2}$ sabiendo que sólo la contribución del ruido térmico debe tenerse en cuenta en el cálculo de la tasa de entropía. En este sentido, en \cite{Fischer2014} se propone un método se propone un método de evaluación embebida de la aleatoriedad (tasa de entropía por bit) basado en la medida de la varianza del jitter.

            Se puede concluir que si el tamaño de los tres parámetros del modelo antes mencionados puede obtenerse a partir del límite inferior de entropía requerido, puede utilizarse una medición en línea de estos parámetros para verificar que el generador no desciende por debajo de este valor. Esta medición y la comparación con los umbrales obtenidos a partir del modelo constituyen una base para las pruebas en línea específicas.



	
    \section{Estándares de diseño y certificación de TRNG}
	
	    %\subsection{Estándares para el diseño y certificación de TRNG}
	
            Diferentes aplicaciones criptográficas requieren distintos niveles de seguridad, lo que ha llevado a la necesidad de estandarizar el uso de la criptografía para aplicaciones específicas. Ya existen muchos estándares que proporcionan algoritmos estándar para el cifrado como el AES \cite{Dworkin2001, JoanDaemen2020} o funciones hash como el SHA-3 \cite{Dang2015}. Sin embargo, debido a que los TRNG son específicos de cada tecnología y plataforma, no es posible proporcionar un diseño estandarizado. Por esta razón, varias autoridades de certificación han desarrollado enfoques estándar para la certificación de TRNG.

            El primer intento de certificación del diseño de TRNG se centró únicamente en comprobar las propiedades estadísticas de los números generados. Para ello se propusieron muchos conjuntos de pruebas, como FIPS 140-1, DIEHARD, NIST 800-22 \cite{Nist2010}, TestU01 entre otros. La idea detrás de las pruebas estadísticas de los TRNG es que deben producir una secuencia de salida que no se distinga de la secuencia ideal, la cual es estacionaria, uniformemente distribuida y con muestras independientes. Aunque las propiedades estadísticas pueden comprobarse fácilmente mediante pruebas estadísticas adecuadas, su independencia no puede ser verificada. El problema con este tipo de pruebas para TRNG es que consideran al generador como una caja negra y solo se tiene en cuenta su salida. Si se utiliza un buen generador de números pseudoaleatorios en lugar de un TRNG, su resultado superará todas las pruebas estadísticas que se le realicen debido a que están hechos de algoritmos que producen secuencias con propiedades estadísticas perfectas, aunque su resultado no es realmente aleatorio, solo parece serlo, ya que su comportamiento está definido y es predecible como resultado de los algoritmos utilizados.

            La evaluación de las propiedades estadísticas de un TRNG es necesaria, pero claramente no suficiente. Es por esto que existen normas más recientes que exigen la caracterización de la fuente de ruido, además de las pruebas estadísticas. Estas normas son la AIS-20/31 \cite{AIS2011} de la Oficina Federal Alemana de Seguridad de la Información (BSI) y la NIST 800-90B \cite{Turan2018} del Instituto Nacional de Estándares y Tecnología de Estados Unidos. Aunque las dos normas utilizan una metodología de evaluación ligeramente diferente, comparten la misma idea básica de la arquitectura de un TRNG. La Figura \ref{fig:A1_TRNG_estructura} muestra un diagrama de bloques de un TRNG de acuerdo con las especificaciones de AIS-20/31 y NIST 800-90B.

            La fuente de ruido digital está compuesta por una fuente de ruido analógica y un digitalizador (extractor de aleatoriedad). Este bloque es el único que extrae la verdadera aleatoriedad del proceso subyacente, y proporciona la salida de señal binaria en bruto. Su salida debe estar disponible para su evaluación con el fin de comprobar la calidad de la señal en bruto y estimar la tasa de entropía a la salida. Es importante destacar que el postprocesamiento es un proceso algorítmico y, por lo tanto, es posible calcular fácilmente la tasa de entropía a la salida del generador a partir de la tasa de entropía a su entrada, que se conoce a partir del modelo y que puede ser verificada probando los datos de la señal en bruto. Es importante señalar que según la norma AIS-20/31, el postprocesamiento no debe reducir la entropía. Ambas normas, AIS-20/31 y NIST 800-90B, consideran el postprocesamiento como una opción. No obstante lo ideal sería que un buen TRNG no necesitara ningún postprocesamiento algorítmico.

            Las pruebas integradas son una parte obligatoria del diseño de un TRNG. Según AIS-20/31, estas pruebas incluyen al menos dos tipos: la prueba de fallo total y las pruebas en línea. La prueba de fallo total debe ser capaz de detectar rápidamente la pérdida completa de entropía en la fuente, con una baja probabilidad de falsas alarmas. Esta pérdida total de entropía podría deberse a un cambio rápido o a la pérdida completa de la conexión física con la fuente. Por otro lado, las pruebas en línea deben ser capaces de detectar defectos irreparables en la secuencia de salida. Estos defectos irreparables son fallos estadísticos que no pueden corregirse con el postprocesamiento, y pueden ocurrir cuando el dispositivo funciona fuera de su rango de parámetros de funcionamiento, como en situaciones de sobretensión, subtensión o temperaturas extremas. Las pruebas en línea pueden ser ejecutadas de manera continua, bajo demanda o activadas por un evento interno específico. Es importante destacar que estas pruebas deben ser superadas con éxito cada vez que se enciende o reinicia el TRNG, por lo que también funcionan como pruebas de encendido. \cite{Petura2019}

                \subsection{Resumen de los requisitos del AIS-20/31}

            La norma AIS-20/31 reconoce varias clases diferentes de TRNGs en función de su principio de funcionamiento:
            
            \begin{itemize}[noitemsep]
                \item Tres clases PTG para los generadores de números aleatorios verdaderos físicos (PTRNG), clases PTG.1 a PTG.3.
                \item Cuatro clases de DRG para los generadores aleatorios deterministas (DRNG), clases DRG.1 a DRG.4.
                \item Una clase NTG para los generadores de números aleatorios verdaderos no físicos, (NPTRNG), clase NTG.1.
            \end{itemize}
            
            Todas las clases de TRNG deben superar las pruebas estadísticas de caja negra. Estas pruebas se dividen en dos procedimientos de prueba descritos en la norma AIS-20/31:

            \begin{itemize}[noitemsep]
                \item El procedimiento de prueba A contiene las pruebas estadísticas T0 a T5. Estas pruebas verifican las propiedades estadísticas generales, como el sesgo, y están destinadas a comprobar los datos postprocesados.
                \item El procedimiento de prueba B contiene las pruebas T6 a T8. Las pruebas T6 y T7 detectan la dependencia entre los números generados. La prueba T8 compara la entropía de Shannon estimada por bit con un umbral de 0.997. El procedimiento de prueba B está destinado a comprobar los datos sin procesar.
            \end{itemize}		

           Las pruebas estadísticas estándar descritas en AIS-20/31 son:

            \begin{itemize}[noitemsep]
                \item T0: Prueba de disyunción
                \item T1: Prueba de monobit  
                \item T2: Prueba de póquer
                \item T3: Prueba de corridas
                \item T4: Prueba de corridas larga
                \item T5: Prueba de autocorrelación
                \item T6: Prueba de distribución uniforme
                \item T7: Prueba de homogeneidad
                \item T8: Estimación de la entropía
            \end{itemize}
        
            \subsubsection{Clase PTG.1 TRNG}

                PTG.1 es una clase de TRNG físico de baja seguridad destinado a aplicaciones que no son críticas para la seguridad. La Figura \ref{fig:E1_PTG1} muestra el diagrama de bloques de dicho generador y los puntos de prueba requeridos por la norma.

                \begin{figure}[hbtp]
                    \caption{Clase PTG.1 TRNG.}
                    \centering
                    \includegraphics[width=0.8\textwidth]{E1_PTG1}
                    \label{fig:E1_PTG1}
                \end{figure}

                \paragraph{Requisitos de la fuente de aleatoriedad\\}
                
                No se requiere ningún modelo estocástico para un PTG.1 TRNG. Sin embargo, la fuente de ruido debe ser física, estar claramente definida y descrita para que quede claro el origen de la aleatoriedad.
                
                \paragraph{Pruebas integradas\\}
                
                La clase PTG.1 requiere la implementación de pruebas de fallo total y en línea. La prueba de fallo total debe detectar un fallo completo de la fuente de aleatoriedad. Las pruebas en línea deben supervisar continuamente y garantizar la calidad estadística de los números aleatorios producidos. La clase PTG.1 requiere que las pruebas en línea supervisen la calidad de los números aleatorios internos (es decir, a la salida del generador).
                
                \paragraph{Post-procesamiento\\}
                
                La clase PTG.1 no requiere que el TRNG utilice ningún tipo de posprocesamiento. Tampoco desaconseja el uso del posprocesamiento. Sin embargo, un TRNG PTG.1 debe superar las pruebas estadísticas del procedimiento de prueba A, por lo que el posprocesamiento puede ser necesario si la señal binaria sin procesar no puede superar dichas pruebas

            \subsubsection{Clase PTG.2 TRNG}
            
                PTG.2 es una clase de TRNG físico, que puede utilizarse para generar claves criptográficas, nonces, semillas para DRNGs, etc. En comparación con la clase PTG.1 de baja seguridad, el TRNG PTG.2 debe garantizar el secreto de los números aleatorios producidos (su imprevisibilidad). La Figura \ref{fig:E2_PTG2} muestra la estructura interna y las pruebas necesarias para el TRNG PTG.2.

                \begin{figure}[hbtp]
                    \caption{Clase PTG.2 TRNG.}
                    \centering
                    \includegraphics[width=0.9\textwidth]{E2_PTG2}
                    \label{fig:E2_PTG2}
                \end{figure}
            
                \paragraph{Requisitos de la fuente de aleatoriedad\\}
                
                Todos los requisitos de la clase PTG.1 se aplican también a la clase PTG.2. Además, se requiere un modelo estocástico para la fuente de aleatoriedad. El modelo estocástico debe tener en cuenta el comportamiento de la fuente de aleatoriedad. Basándose en los parámetros de la fuente, el modelo estima la entropía de la señal binaria sin procesar. La entropía de Shannon de la señal binaria sin procesar debe ser superior a 0.997 por bit según la norma AIS-20/31.
                
                \paragraph{Pruebas integradas\\}
                
                Para un TRNG PTG.2 es necesario implementar tanto las pruebas de fallo total como las pruebas en línea. La prueba de fallo total debe detectar un fallo de la fuente de aleatoriedad total.

                Las pruebas en línea deben detectar las debilidades estadísticas intolerables de la señal binaria sin procesar. Deben funcionar con una señal binaria sin procesar porque el uso del posprocesamiento podría enmascarar algunos defectos potencialmente peligrosos. Las pruebas en línea deben adaptarse al modelo estocástico. De este modo, pueden detectar los defectos específicos de la fuente de aleatoriedad utilizada de forma muy eficaz.

                \paragraph{Post-procesamiento\\}
                
                De forma similar a la clase PTG.1, la clase PTG.2 no requiere el posprocesamiento cuando la señal binaria sin procesar proporciona números aleatorios de suficiente calidad. Si el postprocesamiento es necesario, la clase PTG.2 no pone ninguna restricción en el algoritmo utilizado, sin embargo, no debe reducir la entropía.

            \subsubsection{Clase PTG.3 TRNG}
            
                PTG.3 es una clase TRNG híbrida para TRNGs de alta seguridad. Los TRNG de esta clase no se basan únicamente en la seguridad proporcionada por la fuente de aleatoriedad, sino que añaden una segunda ancla de seguridad en forma de postprocesamiento criptográficamente seguro. Un TRNG híbrido es un TRNG compuesto por un TRNG físico, que vuelve a alimentar continuamente al RNG determinista. En este caso, el RNG determinista sirve como postprocesamiento para el TRNG físico que genera entropía. La Figura \ref{fig:E3_PTG3} muestra el diagrama de bloques de un TRNG híbrido de este tipo.

                \begin{figure}[hbtp]
                    \caption{Clase PTG.3 TRNG.}
                    \centering
                    \includegraphics[width=0.9\textwidth]{E3_PTG3}
                    \label{fig:E3_PTG3}
                \end{figure}
            
                \paragraph{Requisitos de la fuente de aleatoriedad\\}
            
                La fuente de aleatoriedad del TRNG PTG.3 debe cumplir todos los requisitos de la clase PTG.2. La entropía de Shannon de la señal binaria sin procesar debe ser superior a 0.997 por bit, lo que debe estar garantizado por el modelo estocástico de la fuente.

                \paragraph{Pruebas integradas\\}
            
                Además de las pruebas de fallo total y en línea que se exigen también para el TRNG PTG.2, la clase PTG.3 requiere también la prueba de respuesta conocida (KAT) para el posprocesamiento. Esta prueba debe pasar con éxito cada vez que se inicie o reinicie el TRNG para verificar el correcto funcionamiento del algoritmo de posprocesamiento.
                
                \paragraph{Post-procesamiento\\}
            
                A diferencia de los requisitos de PTG.1 y PTG.2, la clase PTG.3 requiere el uso de un postprocesamiento criptográfico. Además, requiere el uso de un DRNG de la clase DRG.3, que proporciona secreto hacia delante y hacia atrás mejorado. Esto significa que el postprocesamiento para un TRNG de clase PTG.3 debe ser una función criptográfica.

            \subsubsection{Clase DRG.1 DRNG}

                La clase DRG.1 establece los requisitos para los RNG deterministas. Los RNG que cumplen con esta norma deben generar una secuencia de números aleatorios que sea indistinguible de la secuencia generada por un RNG ideal a través de simples pruebas estadísticas de caja negra. Además, los DRNG conformes con DRG.1 proporcionan secreto hacia adelante, lo que significa que la seguridad de la secuencia generada no se ve comprometida aunque un atacante tenga acceso a una porción previa de la secuencia. La Figura \ref{fig:E4_DRG1} muestra el diagrama de bloques de este generador.

                Los RNG que cumplen con la norma DRG.1 pueden ser útiles en aplicaciones que requieren datos frescos que difieran de las secuencias previamente generadas con una alta probabilidad. Por ejemplo, pueden ser utilizados para generar retos en protocolos criptográficos o vectores de inicialización en cifradores de bloques en modos especiales de funcionamiento, siempre que no sea necesario proteger la secuencia previa de números aleatorios. Los DRNG que cumplen con DRG.1 son también adecuados para pruebas de conocimiento cero. \cite{AIS2011}

                Para generar la semilla del DRNG se puede utilizar el PTRNG PTG.2 o PRG.3. Si el estado interno es al menos un 25 \% mayor en bits que los límites de entropía mínima, no es necesario una evaluación explícita de la entropía mínima. Esto se justifica por el hecho de que los PTRNG PTG.2 y PTG.3 generan números aleatorios de alta entropía.

                $\varphi$ es la función de transición de estado y $\psi$ es la función de salida

                \begin{figure}[hbtp]
                    \caption{Clase DRNG.1.}
                    \centering
                    \includegraphics[width=0.2\textwidth]{E4_DRG1}
                    \label{fig:E4_DRG1}
                \end{figure}


        \subsection{Resumen de los requisitos del NIST 800-90B}
	
            El NIST 800-90B exige, al igual que el AIS-20/31, que la secuencia de salida del TRNG pase las pruebas de caja negra. Estas pruebas de caja negra se dividen en dos caminos:
            
            \begin{itemize}[noitemsep]
                \item IID track, se utiliza para datos independientes e idénticamente distribuidos o Independent and Identically Distributed en ingles (IID).
                \item Non-IID track, se utiliza para los datos que no superan la prueba de detección de IID.
            \end{itemize}

            Además de superar las pruebas de caja negra, el NIST 800-90B también impone requisitos a los bloques individuales del TRNG.
            
            \paragraph{Fuente de ruido\\}
            
                El NIST 800-90B tiene los siguientes requisitos sobre la fuente de ruido:
                
            \begin{itemize}[noitemsep]
                \item Su comportamiento debe estar descrito..
                \item Su salida debe ser estacionaria.
                \item Debe indicarse la entropía de salida esperada.
                \item Debe protegerse de la observación e influencia de los adversarios.
                \item La fuente de ruido debe tener un comportamiento aleatorio.
            \end{itemize}
            
            Aunque la norma exige la declaración de estacionariedad de la salida y de entropía esperada, no requiere ninguna prueba matemática de estas afirmaciones. Sólo es necesaria la descripción técnica de por qué se cree que la fuente de ruido tiene el comportamiento afirmado.
            
            \paragraph{Pruebas de salud\\}
            
            El NIST 800-90B exige tres tipos de pruebas de salud.
            
            \begin{itemize}[noitemsep]
                \item Las pruebas de puesta en marcha deben verificar si todos los componentes necesarios de la fuente de ruido funcionan correctamente. La fuente de ruido no debe emitir datos antes de que las pruebas de puesta en marcha se completen con éxito.
                \item Las pruebas continuas comprueban los defectos y fallos en el comportamiento de la fuente de ruido. Estas pruebas se realizan de forma continua en todas las muestras emitidas por la fuente de ruido. El NIST 800-90B exige que se utilicen dos pruebas continuas aprobadas. Además de las pruebas aprobadas, también se pueden utilizar pruebas definidas por el desarrollador. La norma permite a los desarrolladores no utilizar las pruebas aprobadas, pero en su lugar deben utilizarse otras pruebas continuas que pueden detectar el mismo tipo de defectos que las pruebas aprobadas.
                \item Las pruebas bajo demanda no se realizan hasta que se solicitan. Debe haber una forma de realizar pruebas bajo demanda en la fuente de ruido. Las muestras utilizadas para las pruebas bajo demanda no deben salir hasta que las pruebas se completen con éxito.
            \end{itemize}
            
            \paragraph{Acondicionamiento\\}
            
            El NIST 800-90B entiende por componente acondicionador una función determinista responsable de reducir el sesgo y/o aumentar la tasa de entropía de los bits de salida resultantes \cite{Turan2018}. El componente de acondicionamiento es completamente opcional, por lo que puede omitirse por completo.
            
            La entropía de salida del TRNG se estima después del componente de condicionamiento. El estándar proporciona una lista de algoritmos de condicionamiento comprobados, para los que los desarrolladores pueden reclamar una entropía completa, aunque esta reclamación tiene que ser validada. Estos algoritmos son funciones hash combinadas con cifrado de bloques, para ver la lista de componentes de acondicionamiento verificados ver \cite{Turan2018}.
            
            Se permite el uso de componentes de acondicionamiento no validados, pero estos componentes son penalizados en términos de estimación de entropía. Cuando se utiliza un componente condicionante no validado, la entropía en la salida se multiplica por una constante de 0.999, lo que le impide alcanzar la entropía total.

            Los parámetros recomendados para configurar las pruebas NIST se muestran en la Tabla \ref{tab:NIST_parametros}:

            \begin{table}[htbp]
                \caption{Parámetros recomendados para el conjunto de pruebas del NIST.}
                \begin{center}
                    \resizebox{0.8\linewidth}{!}{ 
                    \begin{NiceTabular}{|l|l|l|}
                        \CodeBefore
                        \rowcolor{lightgray}{1}
                        \Body
                        \hline
                        \textbf{Test}  & \textbf{Configuration item} & \textbf{Setting} \\
                        \hline
                        All tests   & Bits per sequence & 1000000  \\
                        \hline
                        All test   & Number of sequences (sample size) & 1073 \\
                        \hline
                        Frequency test within a block & Block length & 20000  \\
                        \hline
                        Non-overlapping template test  & Template length & 10  \\
                        \hline
                        Overlapping template & Block length & 10 \\
                        \hline
                        Mauler's Universal Statistical test  & Test block length L &  7 \\
                        \hline
                        Mauler's Universal Statistical test  & Initialization steps  &  1280 \\
                        \hline
                        Approximate entropy test & Block length &  8 \\
                        \hline
                        Linear complexity test  & Block length &  1000 \\
                        \hline
                        Serial test & Block length &  16 \\
                        \hline
                    \end{NiceTabular}
                    }
                \label{tab:NIST_parametros}
                \end{center}
            \end{table}
                    
		\subsection{Conclusiones de la certificación de seguridad TRNG}
		
            Hay dos normas principales relativas a los TRNG que están en vigor en la actualidad:
            
            \begin{itemize}[noitemsep]
                \item AIS-20/31 utilizado en muchos países europeos. \cite{AIS2011}
                \item NIST 800-90B utilizado en los Estados Unidos. \cite{Turan2018}
            \end{itemize}
        
            Las dos normas existentes en la actualidad exigen que el diseño de un TRNG esté bien documentado y su funcionamiento interno bien descrito, además de las pruebas estadísticas. También exigen que se realicen pruebas integradas, de modo que un TRNG se supervise continuamente durante su funcionamiento.
        
            Sin embargo, la norma AIS-20/31 profundiza en el problema de la descripción del TRNG y exige que se desarrolle también un modelo estocástico. Las pruebas integradas, según la AIS-20/31, también deben implementarse de acuerdo con el modelo estocástico. Este requisito no se aplica en la norma NIST 800-90B, que da más libertad en el diseño del TRNG, pero no en sus pruebas.

    
    \section{Arquitecturas de núcleos TRNGs en FPGA}

        El cumplimiento de la norma AIS-20/31 significa que los TRNG seleccionados deben tener una fuente de aleatoriedad claramente definida y bien descrita. El modelo estocástico debe ser factible y la salida de datos sin procesar debe estar disponible para las pruebas. La fuente de aleatoriedad también debe ser cuantificable, lo que permitiría su medición dentro del dispositivo. Una medición de este tipo puede constituir una base sólida para realizar pruebas integradas rápidas y eficaces.

        Además del cumplimiento con la norma AIS-20/31, queremos diseños que sean factibles en cualquier dispositivo lógico. Dado que buscamos un diseño general, evitaremos características (por ejemplo, componentes analógicos) que sean específicas sólo para determinadas tecnologías. Dado que los diseños generales serían independientes de la tecnología, también deberían ser factibles en FPGAs.

        Con base en los criterios del AIS-20/31, los núcleos TRNG adecuados para utilizarse en dispositivos lógicos programables (FPGA) que usan estructuras oscilantes son \cite{Petura2016}:
	
        \begin{itemize}
            \item Single-event ring oscillators
                \begin{itemize}
                    \item Elementary ring oscillator based TRNG 
                    \item Coherent sampling ring oscillator based TRNG 
                    \item Multi-ring oscillator based TRNG 
                \end{itemize}
            \item Multi-event ring oscillators with signal collisions
                \begin{itemize}
                    \item Transient effect ring oscillator based TRNG 
                \end{itemize}
            \item Multi-event ring oscillators without signal collisions
                \begin{itemize}
                    \item Self-timed ring based TRNG 
                \end{itemize}
            \item Phase-locked loops
                \begin{itemize}
                    \item PLL based TRNG 
                \end{itemize}
        \end{itemize}

        Todos los TRNG preseleccionados deberían ser viables en todas las familias de FPGA recientes y futuras, ya que no utilizan ninguna característica específica de la familia.

            	
		\subsection{Elementary ring oscillator based TRNG (ERO-TRNG)}
		
                El ERO-TRNG se propuso y modeló en \cite{Baudet2010}. Dos osciladores en anillo idénticos forman la base del generador. Uno de ellos se utiliza para generar una señal de muestreo, que luego se utiliza para muestrear la salida del otro oscilador en anillo utilizando un flip-flop D (DFF). La frecuencia del oscilador de anillo de muestreo se divide por $K$ para obtener una frecuencia más baja de la señal de muestreo, lo que permitiría acumular el jitter del oscilador de anillo muestreado. La Figura \ref{fig:A1_ERO_TRNG} muestra una arquitectura del ERO-TRNG tal y como se implementa en FPGAs.
					
				\begin{figure}[hbtp]
					\caption{Arquitectura del núcleo ERO-TRNG.}
					\centering
					\includegraphics[width=0.8\linewidth]{A1_ERO_TRNG}
					\label{fig:A1_ERO_TRNG}
				\end{figure}
                
            Se utilizan osciladores en anillo compuestos por una puerta NAND y $N - 1$ búferes no inversores para construir un anillo de $N$ elementos. La compuerta NAND puede utilizarse para encender o apagar el oscilador. En FPGA de Xilinx Spartan-6, con 3 elementos, (una compuerta NAND y 2 buffers), se obtienen frecuencias oscilantes en torno a 300 MHz, además el jitter de periodo se mantiene en torno a 4 ps para periodos entre 3 y 8 ns. 

            Los dos parámetros de diseño fundamentales del ERO-TRNG son la frecuencia de los osciladores de anillo y el factor de división $K$ del reloj de referencia. El segundo parámetro de diseño, el divisor $K$, determina el periodo de acumulación de jitter. El periodo de acumulación necesario depende del tamaño del jitter  de fase y del límite inferior de entropía. El límite inferior de entropía viene definido por el modelo estocástico y, para el ERO-TRNG, puede calcularse mediante la ecuación (\ref{eq:entropia_minima}).

            \begin{equation}
                H_{\text{min}}  = 1 - \frac{4}{\pi ^{4} \ln (2) } e^{ \frac{-\pi^{2} \sigma_{th}^{2} K T_{2}}{T_{1}^{3}} } 
                \label{eq:entropia_minima}
            \end{equation}
            donde $\sigma_{th}^{2}$ es la varianza del jitter debida al ruido térmico, $K$ es el factor de división de la frecuencia de referencia y $T_{1}$, $T_{2}$ son los periodos de oscilación de los dos osciladores en anillo. Además se tiene la relación:

            \begin{equation}
                \sigma_{\text{jit}} = \sqrt{ \frac{K \sigma_{th}^{2} }{4} }
                \label{eq:relacion}
            \end{equation}

            Para un periodo de oscilación de 3 ns, sólo es necesario encontrar el tamaño de jitter de periodo de los osciladores en anillo. Mediciones del jitter de periodo para FPGAs de Xilinx Spartan-6 correspondientes a un periodo de 3 ns arrojan un $\sigma_{T} \approx 4ps$. Realizando los calculamos, el factor de división $K$ según la ecuación (\ref{eq:entropia_minima}) es $K = 80 000$.

            La implementación del ERO-TRNG es sencilla y los resultados son repetibles sin ninguna intervención manual. La colocación manual de los osciladores de anillo proporciona un mejor control de la frecuencia oscilatoria resultante, pero no es necesaria para el diseño adecuado del TRNG. La colocación de los osciladores de anillo ayuda a conservar las mismas propiedades de los osciladores a lo largo de diferentes proyectos o diferentes iteraciones de un proyecto \cite{Choi2021}.

            El ERO-TRNG proporciona una tasa de bits de salida relativamente baja, porque $K$ tiene que ser relativamente alto para garantizar una entropía suficiente. Sin embargo, una vez configurado correctamente, este TRNG ofrece una gran seguridad gracias a su sólido modelo estocástico. Las pruebas integradas sólo tienen que comprobar que los osciladores de anillo oscilan y que no están bloqueados \cite{Bochard2010,Wold2008}.

            El consumo de energía del oscilador en anillo no depende de su tamaño (número de elementos), porque sólo se propaga un evento por el anillo. Por lo tanto, sólo un elemento del oscilador en anillo está activo (cambia de estado) a la vez, independientemente de la frecuencia del oscilador. El consumo de energía de todo el TRNG depende de las frecuencias de los osciladores en anillo utilizados.

		\subsection{Coherent sampling ring oscillator based TRNG (COSO-TRNG)}

                El COSO-TRNG se propuso por primera vez en \cite{Kohlbrenner2004}. Utiliza dos osciladores de anillo implementados idénticamente como fuente de aleatoriedad. La Figura \ref{fig:A2_COSO_TRNG} muestra la estructura interna del COSO-TRNG.
				\begin{figure}[hbtp]
					\caption{Arquitectura del núcleo COSO-TRNG.}
					\centering
					\includegraphics[width=0.8\linewidth]{A2_COSO_TRNG}
					\label{fig:A2_COSO_TRNG}
				\end{figure}

                Aunque los dos osciladores en anillo tengan exactamente la misma estructura interna, sus frecuencias varían un poco. Esta pequeña variación provoca una diferencia de fase en las salidas de los osciladores de anillo. Al muestrear la salida de uno de los osciladores mediante un flip-flop D (DFF) sincronizado con la salida del otro oscilador, obtenemos una señal con un periodo variable, que corresponde al desfase relativo de los dos osciladores.

                El segundo flip flop es un flip-flop T (TFF), que corresponde a un contador de un bit que cuenta el número de flancos ascendentes de la señal del DFF durante un semiperiodo de la señal. Este último bit del contador se registra en el último DFF y se envía a la salida del TRNG como un bit aleatorio.

                COSO-TRNG extrae aleatoriedad del jitter sólo si se cumple la condición de la ecuación (\ref{eq:condicion_coso}).

                \begin{equation}
                    \Delta_{T} < \Delta_{T_{\text{max}}}  = \sqrt[3]{\sigma_{T}^{2} \cdot T}
                    \label{eq:condicion_coso}
                \end{equation}
	
                Desgraciadamente, esta condición es muy difícil de cumplir, ya que los dos osciladores de anillo deben oscilar a frecuencias muy cercanas evitando el bloqueo entre ellos. En una FPGA, satisfacer esta condición es muy difícil ya que no tenemos un control preciso sobre la colocación y el enrutamiento de los anillos, es muy difícil, si no imposible, implementar dos anillos oscilando a frecuencias suficientemente cercanas pero no idénticas.

                Debido a la extrema sensibilidad a $\Delta_{T}$, el diseño que funciona en una FPGA no es directamente transferible a otra FPGA incluso de la misma familia porque incluso el más mínimo cambio causado por la variación del proceso de fabricación puede hacer que la diferencia de período oscile por encima de $\Delta_{T_{\text{max}}} $.  Así que el diseño debe colocarse y encaminarse manualmente para cada FPGA individual, lo que lo hace muy poco práctico. 

                Sin embargo, COSO-TRNG puede proporcionar una tasa de bits de salida relativamente alta con una huella de área baja.

                El consumo de energía del COSO-TRNG es muy reducido, ya que la energía consumida por los osciladores en anillo es independiente de su tamaño y el COSO-TRNG sólo presenta tres flip flops que aumentan su consumo de energía.

		\subsection{Multi-ring oscillator based TRNG (MURO-TRNG)}

            El MURO-TRNG utiliza múltiples osciladores en anillo, que se supone que son independientes, tienen la misma frecuencia media y fases uniformemente distribuidas. Para extraer de forma fiable la aleatoriedad de un grupo de osciladores en anillo, el número de osciladores en anillo debe satisfacer la condición de la ecuación (\ref{eq:muro_condicion}), que especifica la relación entre el periodo medio de oscilación de todos los osciladores, su jitter y el número de osciladores utilizados. La Figura \ref{fig:A3_MURO_TRNG} muestra la estructura interna del MURO-TRNG.

			    \begin{equation}
			     m > \frac{T}{\sigma} 
			     \label{eq:muro_condicion}
			    \end{equation}	

            El principio TRNG sólo funcionará si las fases de los osciladores de anillo están uniformemente distribuidas. Sin embargo, los osciladores en anillo pueden bloquearse entre sí, en cuyo caso la distribución de las fases no será uniforme. Es más, la probabilidad de bloqueo es alta dado el elevado número de anillos necesarios para obtener una entropía alta en el MURO-TRNG.

            El MURO-TRNG no requiere ninguna colocación o encaminamiento manual y su tasa de bits de salida, así como la tasa de entropía, son muy altas cuando se utiliza un número suficiente de osciladores de anillo. El consumo de energía de este TRNG es considerable debido al elevado número de osciladores.
				
				\begin{figure}[hbtp]
					\caption{Arquitectura del núcleo MURO-TRNG.}
					\centering
					\includegraphics[width=0.8\linewidth]{A3_MURO_TRNG}
					\label{fig:A3_MURO_TRNG}
				\end{figure}


		\subsection{Transient effect ring oscillator based TRNG (TERO-TRNG)}

            El TERO-TRNG genera bits aleatorios utilizando metaestabilidad oscilatoria, la Figura \ref{fig:A4_TERO_TRNG} muestra la implementación del TERO-TRNG.

            El el flip-flop TFF representa el último bit del contador, que cuenta el número de oscilaciones de la celda TERO. Debido a la metaestabilidad oscilatoria del TERO, el número de oscilaciones es aleatorio. Para producir un flujo de bits aleatorios, el TERO debe reiniciarse periódicamente \cite{Haddad2015}.
	
            \begin{figure}[hbtp]
                \caption{Arquitectura del núcleo TERO-TRNG.}
                \centering
                \includegraphics[width=0.7\linewidth]{A4_TERO_TRNG}
                \label{fig:A4_TERO_TRNG}
            \end{figure}

            Para conseguir suficiente entropía en la salida del TERO-TRNG, el número de oscilaciones del TERO debe estar dentro de los límites especificados por la ecuación (\ref{eq:limites_tero}).

            \begin{equation}
                100 < M < \frac{T_{\text{meas}}}{T_{\text{osc}}} 
                \label{eq:limites_tero}
            \end{equation}
            donde $M$ es el número de oscilaciones, $T_{\text{meas}}$ es el tiempo de medida y $T_{\text{osc}}$ es el periodo de la señal de salida del TERO.

            El límite inferior para el número de oscilaciones garantiza que habrá suficientes oscilaciones de las que extraer la aleatoriedad. El límite superior, en cambio, evita los casos en los que las oscilaciones no se detienen antes de reiniciar la medición. Cumplir esta condición de forma fiable para varios dispositivos es difícil porque la célula TERO se comporta de forma diferente en cada dispositivo (incluso dentro de una misma familia) aunque se utilice la misma configuración.

                La celda TERO en sí no requiere una gran superficie y sólo se necesitan unos pocos flip flops para los contadores y el núcleo TRNG \cite{Bernard2018}, por lo que la superficie total ocupada es relativamente pequeña. La energía consumida por el TERO no depende del número de elementos del TERO, pero el consumo de energía de los flip flops puede aumentar con el incremento de la frecuencia de reloj. El TERO-TRNG requiere una colocación y enrutamiento manuales y el diseño no es repetible ni siquiera en dispositivos de la misma familia.
				
		\subsection{Self-timed ring based TRNG (STR-TRNG)}

                Un anillo autotemporizado es un oscilador multievento sin colisiones de señales. La Figura \ref{fig:A5_STR_TRNG} muestra la implementación del SRT-TRNG.
	
				\begin{figure}[hbtp]
					\caption{Arquitectura del núcleo STR-TRNG.}
					\centering
					\includegraphics[width=0.8\linewidth]{A5_STR_TRNG}
					\label{fig:A5_STR_TRNG}
				\end{figure}

                Un STR se compone de celdas L Muller (elementos C). Múltiples eventos pueden propagarse a través de un STR sin colisiones. Debido a las propiedades temporales de las STR, los eventos pueden propagarse en los dos modos: modo ráfaga y modo uniforme.

                El principio de extracción de aleatoriedad de un STR-TRNG es el mismo que el de MURO-TRNG: el uso de un conjunto de señales de reloj con fases distribuidas uniformemente. Pero mientras que en muchos osciladores de anillo las fases se distribuyen estadísticamente, en STR la uniformidad de la distribución está garantizada por el principio. 

                El STR-TRNG consume mucha energía debido a que hay muchos eventos propagándose por el anillo. En el modo uniformemente espaciado, un STR oscila a su frecuencia máxima. La tasa de bits de salida del STR-TRNG es muy alta, lo que también contribuye a su elevado consumo de energía. El STR-TRNG requiere una gran superficie y, para garantizar que funciona en modo uniformemente espaciado, es necesario colocar manualmente los elementos STR.
				
				
		\subsection{PLL based TRNG (PLL-TRNG)}
				
				\begin{figure}[hbtp]
					\caption{Arquitectura del núcleo PLL-TRNG.}
					\centering
					\includegraphics[width=0.8\linewidth]{A6_PLL_TRNG}
					\label{fig:A6_PLL_TRNG}
				\end{figure}

                El PLL-TRNG no requiere ninguna colocación o encaminamiento manual. Proporciona alta seguridad y no se ve afectado por el ruido determinista global (es decir, dependiente de los datos), ya que los PLL están físicamente aislados del resto de la FPGA. La tasa de bits de salida del PLL-TRNG también es considerable \cite{Fischer2019}.

                El diseño del PLL-TRNG es sencillo, repetible y puede automatizarse. Sin embargo, la elección de los parámetros del PLL no es trivial. Hay que respetar muchas restricciones, incluidas las físicas del fabricante del PLL  y las de seguridad del TRNG. 

                La huella de área del PLL-TRNG es relativamente pequeña si excluimos los PLL, que no ocupan lógica FPGA. Los PLL en sí no son baratos de implementar, ya que requieren un área de silicio considerable. En las FPGA, por el contrario, los PLL ya están incluidos, por lo que su uso no supone ningún coste. Es más, la mayoría de las familias de FPGAs proporcionan varios PLLs, lo que reduce aún más el coste de la implementación del PLL-TRNG.

                El consumo de energía del PLL-TRNG depende de los PLLs proporcionados en la FPGA concreta. Algunas familias tienen todos los PLL activados por defecto, aunque no se utilicen (por ejemplo, las FPGA de Intel). En una familia así, PLL-TRNG no consume mucha más energía que una FPGA vacía, porque en ambos casos los PLL están funcionando. El consumo de energía es considerable en otras familias, que tienen los PLL apagados por defecto. Un PLL-TRNG implementado en una familia de este tipo consumirá mucha más energía que una FPGA vacía.
				
            \subsection{Comparación entre nucleos TRNG}

            En la Tabla \ref{tab:resumen_de_trng_cores} extraída de \cite{Petura2016} se muestra un resumen de las cualidades de cada uno de los núcleos TRNG que implemento el autor en diferentes familias de FPGA.

                \begin{table}[htbp]
                  \centering
                    \caption{Resumen de los resultados núcleos TRNGs \cite{Petura2016}.}
                    \resizebox{0.8\linewidth}{!}{ 
                        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
                            \hline
                            \rowcolor{lightgray} TRNG Type & FPGA  & Area  & Power cons. & Bit Rate & Efficiency & Entropy & Entropy * Bit rate & Feasib. \\
                            \rowcolor{lightgray}       & device & (LUT/Reg) & [mW]  & [Mbits/s] & [bits/$\mu$Ws] & per bit &       & \& Repeat. \\
                            \hline
                            \multirow{3}[2]{*}{ERO} & Spartan 6 & 46/19 & 2.16  & 0.0042 & 1.94  & 0.999 & 0.004 & \multirow{3}[2]{*}{5} \\
                                  & Cyclone V & 34/20 & 3.24  & 0.0027 & 0.83  & 0.990 & 0.003 &  \\
                                  & SmartFusion 2 & 45/19 & 4     & 0.014 & 3.5   & 0.980 & 0.013 &  \\
                            \hline
                            \multirow{3}[2]{*}{COSO} & Spartan 6 & 18/3  & 1.22  & 0.54  & 442.6 & 0.999 & 0.539 & \multirow{3}[2]{*}{1} \\
                                  & Cyclone V & 13/3  & 0.9   & 1.44  & 1600  & 0.999 & 1.438 &  \\
                                  & SmartFusion 2 & 23/3  & 1.94  & 0.328 & 169   & 0.999 & 0.327 &  \\
                            \hline
                            \multirow{3}[2]{*}{MURO} & Spartan 6 & 521/131 & 54.72 & 2.57  & 46.9  & 0.999 & 2.567 & \multirow{3}[2]{*}{4} \\
                                  & Cyclone V & 525/130 & 34.93 & 2.2   & 62.9  & 0.999 & 2.197 &  \\
                                  & SmartFusion 2 & 545/130 & 66.41 & 3.62  & 54.5  & 0.999 & 3.616 &  \\
                            \hline
                            \multirow{3}[2]{*}{PLL} & Spartan 6 & 34/14 & 10.6  & 0.44  & 41.5  & 0.981 & 0.431 & \multirow{3}[2]{*}{3} \\
                                  & Cyclone V & 24/14 & 23    & 0.6   & 43.4  & 0.986 & 0.592 &  \\
                                  & SmartFusion 2 & 30/15 & 19.7  & 0.37  & 18.7  & 0.921 & 0.340 &  \\
                            \hline
                            \multirow{3}[2]{*}{TERO} & Spartan 6 & 39/12 & 3.312 & 0.625 & 188.7 & 0.999 & 0.624 & \multirow{3}[2]{*}{1} \\
                                  & Cyclone V & 46/12 & 9.36  & 1     & 106.8 & 0.987 & 0.985 &  \\
                                  & SmartFusion 2 & 46/12 & 1.23  & 1     & 813   & 0.999 & 0.999 &  \\
                            \hline
                            \multirow{3}[2]{*}{STR} & Spartan 6 & 346/256 & 65.9  & 154   & 2343.2 & 0.998 & 154.121 & \multirow{3}[2]{*}{2} \\
                                  & Cyclone V & 352/256 & 49.4  & 245   & 4959.1 & 0.999 & 244.755 &  \\
                                  & SmartFusion 2 & 350/256 & 82.52 & 188   & 2286.7 & 0.999 & 188.522 &  \\
                            \hline
                        \end{tabular}%
                    }
                  \label{tab:resumen_de_trng_cores}
                \end{table}%

                El mensaje más importante que transmite la Tabla \ref{tab:resumen_de_trng_cores} es que no hay ningún TRNG que destaque en todos los parámetros evaluados ni tampoco hay ningún generador que sea el peor en todos los aspectos. Estos resultados confirman que ningún TRNG puede satisfacer las necesidades de todas las aplicaciones. Muchos parámetros de diseño dependen unos de otros, lo que crea compensaciones en un diseño y hay que llegar a un compromiso en favor de los parámetros preferidos.

